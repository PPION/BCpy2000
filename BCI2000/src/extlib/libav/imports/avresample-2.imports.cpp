// Import declarations for avresample-2 library
// generated by C:\BCI2000.svn\build\buildutils\create_import_table.exe from win32-x86/dynamic/avresample-2.dll
#if STATIC_LIBAVRESAMPLE_2

namespace Dylib { bool avresample_2_Loaded() { return true; } }
extern "C" {
}

#else

#include "DylibImports.h"
namespace { extern const Dylib::Import* functionImports; }

// Here you may specify a custom error message to be displayed when the library cannot be found.
static const char* notFoundMsg = "";
// Here you may specify an URL to some local or remote help resource.
static const char* notFoundURL = "";
RegisterDylibWithAliases( avresample_2, "avresample-2", functionImports, notFoundMsg, notFoundURL );

extern "C" {

// NOTE: When loading the library, function bodies will be overwritten with absolute jumps
// to imported functions, i.e. function bodies must be roughly 2 * sizeof(void*) bytes long.
// A call to a member function with a pointer argument should be large enough.
// 
// In addition, having distinct function bodies for each function stub
// is important -- that makes it impossible for size optimizers to
// collapse them into a single definition.
//
void avresample_alloc_context() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_alloc_context" ); }
void avresample_available() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_available" ); }
void avresample_build_matrix() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_build_matrix" ); }
void avresample_close() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_close" ); }
void avresample_config() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_config" ); }
void avresample_configuration() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_configuration" ); }
void avresample_convert() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_convert" ); }
void avresample_convert_frame() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_convert_frame" ); }
void avresample_free() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_free" ); }
void avresample_get_class() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_get_class" ); }
void avresample_get_delay() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_get_delay" ); }
void avresample_get_matrix() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_get_matrix" ); }
void avresample_get_out_samples() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_get_out_samples" ); }
void avresample_is_open() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_is_open" ); }
void avresample_license() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_license" ); }
void avresample_open() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_open" ); }
void avresample_read() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_read" ); }
void avresample_set_channel_mapping() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_set_channel_mapping" ); }
void avresample_set_compensation() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_set_compensation" ); }
void avresample_set_matrix() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_set_matrix" ); }
void avresample_version() { Dylib::avresample_2.UninitializedFunctionExport( "avresample_version" ); }
}

namespace {
const Dylib::Import functionImports_[] =
{
  { "avresample_alloc_context", (void**)&avresample_alloc_context, Dylib::Import::functionStub },
  { "avresample_available", (void**)&avresample_available, Dylib::Import::functionStub },
  { "avresample_build_matrix", (void**)&avresample_build_matrix, Dylib::Import::functionStub },
  { "avresample_close", (void**)&avresample_close, Dylib::Import::functionStub },
  { "avresample_config", (void**)&avresample_config, Dylib::Import::functionStub },
  { "avresample_configuration", (void**)&avresample_configuration, Dylib::Import::functionStub },
  { "avresample_convert", (void**)&avresample_convert, Dylib::Import::functionStub },
  { "avresample_convert_frame", (void**)&avresample_convert_frame, Dylib::Import::functionStub },
  { "avresample_free", (void**)&avresample_free, Dylib::Import::functionStub },
  { "avresample_get_class", (void**)&avresample_get_class, Dylib::Import::functionStub },
  { "avresample_get_delay", (void**)&avresample_get_delay, Dylib::Import::functionStub },
  { "avresample_get_matrix", (void**)&avresample_get_matrix, Dylib::Import::functionStub },
  { "avresample_get_out_samples", (void**)&avresample_get_out_samples, Dylib::Import::functionStub },
  { "avresample_is_open", (void**)&avresample_is_open, Dylib::Import::functionStub },
  { "avresample_license", (void**)&avresample_license, Dylib::Import::functionStub },
  { "avresample_open", (void**)&avresample_open, Dylib::Import::functionStub },
  { "avresample_read", (void**)&avresample_read, Dylib::Import::functionStub },
  { "avresample_set_channel_mapping", (void**)&avresample_set_channel_mapping, Dylib::Import::functionStub },
  { "avresample_set_compensation", (void**)&avresample_set_compensation, Dylib::Import::functionStub },
  { "avresample_set_matrix", (void**)&avresample_set_matrix, Dylib::Import::functionStub },
  { "avresample_version", (void**)&avresample_version, Dylib::Import::functionStub },
  { 0, 0, 0 }
};
const Dylib::Import* functionImports = functionImports_;
}

#endif // STATIC_LIBAVRESAMPLE_2

